---
categories: ASP.net
---

# Filter

过滤管道

![image](/Images/FilterPipeline.png)

这里为`Endpoint Middleware`中间件

## IActionFilter

控制器的方法过滤器

创建过滤器
```C#
public class PersonsListActionFilter :IActionFilter
{
    private readonly ILogger<PersonsListActionFilter> _logger;

    public PersonsListActionFilter(ILogger<PersonsListActionFilter>  logger)
    {
        _logger = logger;
    }
    
    //在执行Action前
    public void OnActionExecuting(ActionExecutingContext context)
    {
        _logger.LogInformation("PersonsListActionFilter.onActionExecuting method");
    }
    
    //在执行Action后
    public void OnActionExecuted(ActionExecutedContext context)
    {
        _logger.LogInformation("PersonsListActionFilter.OnActionExecuted method");
    }
}
```
添加过滤器
```C#
//添加过滤器
[TypeFilter(typeof(PersonsListActionFilter))]
public async Task<ActionResult> Index()
{

}
```

例子

方法执行中, context中可以访问参数.
```C#
public void OnActionExecuting(ActionExecutingContext context)
{
    //执行方法后的context无法得到参数,所以保存在HttpContext
    context.HttpContext.Items["arguments"] = context.ActionArguments;

    _logger.LogInformation("PersonsListActionFilter.onActionExecuting method");

    //查看action参数中是否包含searchBy
    if (context.ActionArguments.ContainsKey("searchBy"))
    {
        //转化为string
        var searchBy = Convert.ToString(context.ActionArguments["searchBy"]);
        
        //如果不为空
        if (!String.IsNullOrEmpty(searchBy))
        {
            //创建一个有效列表
            var searchByOptions = new List<string>()
            {
                nameof(PersonResponse.PersonName),
                nameof(PersonResponse.Email),
                nameof(PersonResponse.DateOfBirth),
                nameof(PersonResponse.Gender),
                nameof(PersonResponse.CountryId),
                nameof(PersonResponse.Address),
            };

            //如果searchBy不是有效列表中的值，就将它重置为PersonName.
            if (searchByOptions.Any(temp => temp == searchBy)==false)
            {
                _logger.LogInformation("searchBy actual value {searchBy}",searchBy);
                context.ActionArguments["searchBy"] = nameof(PersonResponse.PersonName);
                _logger.LogInformation("searchBy actual value {searchBy}",searchBy);
            }
        }
    }
}
```
方法执行后
```C#
public void OnActionExecuted(ActionExecutedContext context)
{
    _logger.LogInformation("PersonsListActionFilter.OnActionExecuted method");

    var personsController = context.Controller as PersonsController;
    
    IDictionary<string,object?>? parameters = context.HttpContext.Items["arguments"] as IDictionary<string, object?>;

    if (parameters != null)
    {
        if (parameters.ContainsKey("searchBy"))
        {
            personsController.ViewData["CurrentsearchBy"] = parameters["searchBy"].ToString();
        }
        if (parameters.ContainsKey("searchString"))
        {
            personsController.ViewData["CurrentsearchString"] = parameters["searchString"].ToString();
        }
        if (parameters.ContainsKey("SortBy"))
        {
            personsController.ViewData["CurrentSortBy"] = parameters["SortBy"].ToString();
        }
        if (parameters.ContainsKey("SortOrder"))
        {
            personsController.ViewData["CurrentSortOrder"] = parameters["SortOrder"].ToString();
        }
    }
}

//PersonsController.cs中可以注释一下几句
//ViewBag.CurrentSearchBy=searchBy;
//ViewBag.CurrentSearchString=searchString;
//ViewBag.CurrentSortBy=sortBy;
//ViewBag.CurrentSortOrder=sortOrder.ToString();
```

### 传入参数

```C#
public class ResponseHeaderActionFilter : IActionFilter
{
    private readonly ILogger<ResponseHeaderActionFilter> _logger;
    private readonly string _key;
    private readonly string _value;

    //构造器中接收参数
    public ResponseHeaderActionFilter(ILogger<ResponseHeaderActionFilter> logger,string Key,String Value)
    {
        _logger = logger;
        _key = Key;
        _value = Value;
    }

    public void OnActionExecuting(ActionExecutingContext context)
    {
        _logger.LogInformation("{FilterName}.{MethodName} method",nameof(ResponseHeaderActionFilter),nameof(ActionExecutingContext));
        throw new NotImplementedException();
    }

    public void OnActionExecuted(ActionExecutedContext context)
    {
        _logger.LogInformation("{FilterName}.{MethodName} method",nameof(ResponseHeaderActionFilter),nameof(ActionExecutedContext));
        throw new NotImplementedException();

        context.HttpContext.Response.Headers[_key] = _value;
    }
}
```

```C#
[TypeFilter(typeof(ResponseHeaderActionFilter),Arguments = new object[]{"X-Custom-Key","Custom-Value"})]

public async Task<ActionResult> Index()
{

}

如果Action里面也有参数，那么Arguments也能得到.
```

### 级别

有三个级别,方法级别,控制器级别,全局级别,其实就是写在不同地方.

写在方法上,写在类上,写在Program里.

先执行全局,再执行类,再执行Action,由宽到窄.

全局级别写法
```C#
//Program.cs

builder.Services.AddControllersWithViews(options =>
{
    //泛型无法提供参数,括号里面的为Order
    //options.Filters.Add<ResponseHeaderActionFilter>(1);
    var logger = builder.Services.BuildServiceProvider().GetRequiredService<ILogger<ResponseHeaderActionFilter>>();
    options.Filters.Add(new ResponseHeaderActionFilter(logger,"My-Key-From-Global","My-Value-From-Global"));  
});
```

### 顺序

`[TypeFilter(typeof(PersonsListActionFilter),Order = 1)]`

`options.Filters.Add<ResponseHeaderActionFilter>(1);`
用Order设置顺序,小的优先，同Order还是按照老顺序.不同则按Order.

## IOrderedFilter

方便全局即写参数,又写order.

```C#
//实现IOrderedFilter，其实就多了一个Order属性.
public class ResponseHeaderActionFilter : IActionFilter,IOrderedFilter
{
    private readonly ILogger<ResponseHeaderActionFilter> _logger;
    private readonly string _key;
    private readonly string _value;

    //构造器接收Order
    public ResponseHeaderActionFilter(ILogger<ResponseHeaderActionFilter> logger,string Key,String Value,int order)
    {
        _logger = logger;
        _key = Key;
        _value = Value;
        Order = order;
    }

    public void OnActionExecuting(ActionExecutingContext context)
    {
        _logger.LogInformation("{FilterName}.{MethodName} method",nameof(ResponseHeaderActionFilter),nameof(ActionExecutingContext));
    }

    public void OnActionExecuted(ActionExecutedContext context)
    {
        _logger.LogInformation("{FilterName}.{MethodName} method",nameof(ResponseHeaderActionFilter),nameof(ActionExecutedContext));

        context.HttpContext.Response.Headers[_key] = _value;
    }

    //Order属性
    public int Order { get; set; }
}
```

```C#
builder.Services.AddControllersWithViews(options =>
{
    var logger = builder.Services.BuildServiceProvider().GetRequiredService<ILogger<ResponseHeaderActionFilter>>();
    options.Filters.Add(new ResponseHeaderActionFilter(logger,"My-Key-From-Global","My-Value-From-Global",1));  
});
```

## IAsyncActionFilter

可以调用异步方法

```C#
public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)
{
    //执行前
    _logger.LogInformation("{FilterName}.{MethodName} method",nameof(ResponseHeaderActionFilter),nameof(ActionExecutionDelegate));

    //调用后续过滤器，如果不调用那么就是短路
    await next();
    
    //执行后
    _logger.LogInformation("{FilterName}.{MethodName} method",nameof(ResponseHeaderActionFilter),nameof(ActionExecutionDelegate));

    context.HttpContext.Response.Headers[_key] = _value;
}
```

## 短路

直接设置context.Result 而且不调用`await next()`，但不会短路结果.(调用await next()会报错).

```C#
public class PersonCreateAndEditPostActionFilter : IAsyncActionFilter
{
    
    private readonly ICountriesService _countriesService;

    public PersonCreateAndEditPostActionFilter(ICountriesService countriesService)
    {
        _countriesService = countriesService;
    }
    
    public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)
    {
        //需要转化为具体控制器才能调用ModelState
        if (context.Controller is PersonsController personsController)
        {
            if (!personsController.ModelState.IsValid)
            {
                List<CountryResponse> allCountries =await _countriesService.GetAllCountries();
                personsController.ViewBag.Countries = allCountries.Select(c=> new SelectListItem
                {
                    Text = c.CountryName,
                    Value = c.CountryID.ToString()
                });
                personsController.ViewBag.Errors = personsController.ModelState.Values.SelectMany(v => v.Errors).Select(e => e.ErrorMessage).ToList();

                //这是Action自己的参数也在Arguments里面.
                var personRequest = context.ActionArguments["personRequest"];

                //这里直接调用View就可以，context里面知道是哪个Action的View
                context.Result = personsController.View(personRequest);
            }
            else
            {
                await next();
            }
        }
        else
        {
            await next();
        }
    }
}
```

## IResultFilter,IAsyncResultFilter

修改结果，或者添加结果.和ActionFilter不同的只在时态.

实际用处不大.

```C#
public class PersonsListResultFilter : IAsyncResultFilter
{
    private readonly ILogger<PersonsListResultFilter> _logger;

    public PersonsListResultFilter(ILogger<PersonsListResultFilter> logger)
    {
        _logger = logger;
    }
    
    public async Task OnResultExecutionAsync(ResultExecutingContext context, ResultExecutionDelegate next)
    {
        _logger.LogInformation("{FilterName}.{MethodName}-before",nameof(PersonsListResultFilter),nameof(ResultExecutingContext));
        
        await next();
        
        _logger.LogInformation("{FilterName}.{MethodName}-after",nameof(PersonsListResultFilter),nameof(ResultExecutingContext));
        
        context.HttpContext.Response.Headers["Last-Modified"]=DateTime.UtcNow.ToString("R");
    }
}
```
## 资源过滤器,IResourceFilter,IAsyncResourceFilter

在模型绑定之前. Executed很少用.一般用来拒绝请求,他比ActionFilter更早，不用经过模型绑定.

```C#
public class FeatureDisabledResourceFilter : IAsyncResourceFilter
{
    private readonly ILogger<FeatureDisabledResourceFilter> _logger;
    private readonly bool _isDisabled;

    public FeatureDisabledResourceFilter(ILogger<FeatureDisabledResourceFilter> logger,bool isDisabled=true)
    {
        _logger = logger;
        _isDisabled = isDisabled;
    }
    
    public async Task OnResourceExecutionAsync(ResourceExecutingContext context, ResourceExecutionDelegate next)
    {
        _logger.LogInformation("{FilterName}.{MethodName}-before",nameof(FeatureDisabledResourceFilter),nameof(ResourceExecutingContext));

        if (_isDisabled)
        { 
            context.Result=new NotFoundResult();
        }
        else
        {
            await next();
        }
        
        _logger.LogInformation("{FilterName}.{MethodName}-after",nameof(FeatureDisabledResourceFilter),nameof(ResourceExecutingContext));

    }
}
```

## 授权过滤器 IAuthorizationFilter,IAsyncAuthorizationFilter

身份验证 登录

授权 权限

```C#
public class TokenAuthorizationFilter : IAsyncAuthorizationFilter
{
    public async Task OnAuthorizationAsync(AuthorizationFilterContext context)
    {
        //验证Cookies
        if (context.HttpContext.Request.Cookies.ContainsKey("Auth-Key")==false)
        {
            context.Result = new StatusCodeResult(StatusCodes.Status401Unauthorized);
            return;
        }
        
        if (context.HttpContext.Request.Cookies["Auth-Key"]!="A100")
        {
            context.Result = new StatusCodeResult(StatusCodes.Status401Unauthorized);
        }
    }
}
```

```C#
public class TokenResultFilter: IAsyncResultFilter
{
    public async Task OnResultExecutionAsync(ResultExecutingContext context, ResultExecutionDelegate next)
    {
        //给浏览器添加Cookie
        context.HttpContext.Response.Cookies.Append("Auth-Key", "A100");
        await next();
    }
}
```

## 异常过滤器 IExceptionFilter,IAsyncExceptionFilter

只为一些特定的操作方法(控制器级别也行)处理特定的异常.才使用.

**如果要处理所有请求和中间件那就应该使用异常处理中间件.**

只能捕获在它时间之前的过滤器.

```C#
//这两个都代表短路
context.Result=some_action_result;

context.ExceptionHandled=true;
```

```C#
public class HandleExceptionFilter :IAsyncExceptionFilter
{
    private readonly ILogger<HandleExceptionFilter> _logger;
    //ASP自动注入
    private readonly IHostEnvironment _hostEnvironment;

    public HandleExceptionFilter(ILogger<HandleExceptionFilter> logger,IHostEnvironment  hostEnvironment)
    {
        _logger = logger;
        _hostEnvironment = hostEnvironment;
    }

    public async Task OnExceptionAsync(ExceptionContext context)
    {
        _logger.LogError("Exception filter {FilterName}.{MethodName}\n{ExceptionType}\n{ExceptionMessage}",nameof(HandleExceptionFilter),nameof(OnExceptionAsync),context.Exception.GetType().ToString(),context.Exception.Message);
        
        if(_hostEnvironment.IsDevelopment())
            context.Result = new ContentResult(){Content = context.Exception.Message,StatusCode = 500};
    }
}
```

## IAlwaysRunResultFilter,IAsyncAlwaysRunResultFilter

强制执行的结果过滤器.通常很少使用.

## 排除过滤器

如果是控制器级别或者全局级别的过滤器，可以排除某些过滤器

```C#
//继承了Attribute的类，可以直接在操作方法或类上注释[],
//IFilterMetadata则是可以充当过滤器,是过滤器的基础接口,即IACtionFilter和其他都实现了.
public class SkipFilter : Attribute,IFilterMetadata
{
    
}
```

```C#
[TypeFilter(typeof(SomeFilter))]

//拥有这个的SomeFilter过不了If.
[SkipFilter]
public class PersonsController : Controller
{
}
```

```C#
//SomeFilter
public void OnActionExecuting(ActionExecutingContext context)
{   
    //直接寻找该请求中所有的Filters里面是否有SkipFilter,如果有就跳过
    if (context.Filters.OfType<SkipFilter>().Any())
    {
        return;
    }
}
```




# 过去版本
面向切面编程

IAsyncExceptionFilter

`OnExceptionAsync()`

## IAsyncActionFilter

分为前代码和后端码

OnActionExecutionAsync()

```C#
Console.Write("执行前");

//执行中,实际的执行代码.如果不调用就是终止
ActionExecutedContext result =await next();

//后代码
if(result.Exception!=null) 
{
    //发生异常
}
else
{Console.Write("执行后")};

```

注册Filter,按照顺序来的

```C#

builder.Services.Configure<MvcOptions>(opt=>{
    opt.Filter.Add<MyActionFilter>();
    })
```