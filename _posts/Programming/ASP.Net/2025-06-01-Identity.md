---
categories: ASP.net
---

# Identity

![image](/Images/Identity.png)

Nuget包

`Microsoft.AspNetCore.Identit`

`Microsoft.AspNetCore.Identit.Entityframeworkcore`

## IdentityUser<T>

储存了基本信息,Id,UserName,PasswordHash,Email,PhoneNumber

T为Id的类型,默认为string

## IdentityRole<T>

用户角色,与权限有关.管理员或用户.

Id,Name

T为Id的类型,默认为string

## IdentityDbcontext<IdentityUser,IdentityRole,T>

不再继承Dbcontext,而是继承IdentityDbcontext.

## 添加服务

```C#
services.AddIdentity<ApplicationUser, ApplicationRole>()
    .AddEntityFrameworkStores<ApplicationDbContext>()
    //添加令牌服务,类似于验证码.
    .AddDefaultTokenProviders();

//如果ApplicationDbContext泛型明确提及了主键,那么就不需要下面这些
//AddUserStore<UserStore<ApplicationUser,ApplicationRole,ApplicationDbContext,Guid>>()
//AddRoleStore<RoleStore<ApplicationRole,ApplicationDbContext,Guid>>();*/
```

**设置好后,需要EFcore迁移更新创建表**

## UserManager

在Identity中不直接操作数据库，而是使用manager,类似于服务类.

```C#
private readonly UserManager<ApplicationUser>  _userManager;

//依赖注入
public AccountController(UserManager<ApplicationUser> userManager)
{
    _userManager = userManager;
}

//registerDTO来源于页面的模型绑定,不设置密码
var user = new ApplicationUser()
{
    Email = registerDTO.Email,
    PhoneNumber = registerDTO.Phone,
    //UserName为账户
    UserName = registerDTO.Email,
    PersonName = registerDTO.PersonName,
};

//密码单独传入,因为数据库存的是哈希值.
IdentityResult result = await _userManager.CreateAsync(user,registerDTO.Password);
```

## SignInManager

`await _signInManager.SignInAsync(user, false)` 登录,false为不保留cookie

`await _signInManager.PasswordSignInAsync(loginDTO.Email, loginDTO.Password, false, false)` 使用账户和密码登录，第3个参数为是否持久Cookie,第四个参数为连续3次失败是否锁定用户.

`await _signInManager.SignOutAsync()` 注销,溢出Cookie.

`app.UseAuthentication()` 启动中间件,才会读取Cookie获得登录信息。**需要在`app.UseRouting()`之下**

`@User.Identity?.Name` 在视图中直接可以获得登录的名称

## 密码复杂度

在添加Identity时候添加option.
```C#
services.AddIdentity<ApplicationUser, ApplicationRole>(options=>
    {
        options.Password.RequiredLength = 5;
        //是否一定要非字母字符
        options.Password.RequireNonAlphanumeric = false;
        options.Password.RequireUppercase = false;
        options.Password.RequireLowercase = true;
        options.Password.RequireDigit = false;
        //至少需要几个不同字符
        options.Password.RequiredUniqueChars = 3;
    })
```

## 授权

权限

`app.UseAuthorization()`

```C#
//中间件有顺序要求
app.UseRouting();
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();
```

服务注册
```C#
services.AddAuthorization(option =>
{
    //AuthorizationPolicyBuilder 政策构建器
    //RequireAuthenticatedUser 需要验证用户,也就是用户必须是验证的,其实是检查Cookie
    option.FallbackPolicy = new AuthorizationPolicyBuilder().RequireAuthenticatedUser().Build();
});

services.ConfigureApplicationCookie(options =>
{
    //如果没有Cookie就会跳转到这个页面
    //如果没登录还会在地址栏中添加一个ReturnUrl方便返回原来的Url
    options.LoginPath="/Account/Login";
});
```

### 自动返回

ReturnUrl会由服务器自动添加到你的请求中,所以可以直接获得，但是提交表单的时候得额外添加.

```C#
//这里为什么需要asp-route-ReturnUrl? 是因为提交表单的时候信息由你设计的表单为标准，而这个ReturnUrl是授权自动添加的,属于额外信息.
<form asp-asp-controller="Account" asp-action="Login" asp-route-ReturnUrl="@Context.Request.Query["ReturnUrl"]" method="post">
```

```C#
public async Task<IActionResult> Login(LoginDTO loginDTO,string? ReturnUrl)
{
    //something...

    if (result.Succeeded)
    {
        //不为空且是否为本地Url(是否为同一程序中的Url)
        if (!string.IsNullOrEmpty(ReturnUrl) && Url.IsLocalUrl(ReturnUrl))
        {
            //return Redirect(ReturnUrl);
            return LocalRedirect(ReturnUrl);
        }
        return RedirectToAction(nameof(PersonsController.Index), "Persons");
    }
}
```

## 远程验证

比如用户名已存在,这需要服务器验证.但不需要刷新页面.

```C#
public async Task<IActionResult> IsEmailAlreadyRegistered(string email)
{
    ApplicationUser? user = await _userManager.FindByEmailAsync(email);
    if (user == null)
    {
        return Json(true);
    }
    else
    {
        return Json(false);
    }
}
```

需要`Microsoft.AspNetCore.Mvc.ViewFeatures`包

```C#
[Remote(action:"IsEmailAlreadyRegistered",controller:"Account",ErrorMessage ="Email already registered")]
public string Email { get; set; }
```

## User Roles

用户角色
```C#
//将该字段依赖注入
private readonly RoleManager<ApplicationRole> _roleManager;

//关于角色注册的核心代码
if (result.Succeeded)
{
    //Check User or Admin
    if (registerDTO.UserType == UserTypeOptions.Admin)
    {
        //查找角色是否已经存在,如果没有则创建
        if (await _roleManager.FindByNameAsync(UserTypeOptions.Admin.ToString())is null)
        {
            ApplicationRole applicationRole = new ApplicationRole()
            {
                Name = UserTypeOptions.Admin.ToString()
            };
            await _roleManager.CreateAsync(applicationRole);
        }
        
        //将用户添加到某角色
        await _userManager.AddToRoleAsync(user, UserTypeOptions.Admin.ToString());
    }
    else
    {   
        //
        await _userManager.AddToRoleAsync(user, UserTypeOptions.User.ToString());
    }

    //Sign in
}
else
{
    //something
}
```

## Areas

区域

脚手架创建MVC区域.

Areas -> admin -> controller | Model | Data | Views 

```C#
[Area("Admin")]
//默认不解析[area]，所以写死
[Route("admin/[controller]/[action]")]
public class HomeController : Controller
{
    // GET: HomeController
    public ActionResult Index()
    {
        return View();
    }

}

```
登录逻辑
```C#
if (result.Succeeded)
{
    //登录成功
    ApplicationUser user = await _userManager.FindByEmailAsync(loginDTO.Email);
    if (user != null)
    {
        //查询是否为admin
        if (await _userManager.IsInRoleAsync(user,UserTypeOptions.Admin.ToString()))
        {
            //重定向并且传入area,就会进入area的admin页面
            return RedirectToAction("Index", "Home", new
            {
                area = "Admin",
            });
        }
    }
}
```

视图
```C#
@if (User.IsInRole("Admin"))
{
    <li>
        <a asp-controller="Home" asp-action="Index" asp-area="Admin">Admin</a>
    </li>
}
```
Areas里面的Views不会用到根目录的Views里面的 `_ViewImports` 和 `_ViewStart`

## 基于角色的身份验证

```C#
//这一行就是角色验证.
[Authorize(Roles = "Admin")]
public class HomeController : Controller
{
  //something
}
```
## 自定义授权

```C#
services.AddAuthorization(option =>
{
    //something
    
    //RequireAssertion 断言
    //return true 就是过
    option.AddPolicy("NotAuthenticated", policy => policy.RequireAssertion(context =>
    {
        return !context.User.Identity.IsAuthenticated;
    }));
});
```

应用
```C#
//应用了我们设置的政策,括号里面不写则为必须要登录
[Authorize("NotAuthenticated")]
public IActionResult Register()
{
    //something
}
```

<details>
<summary>老版本</summary>

## 杨晓东 Savorboard

Claims 身份单元

ClaimsIdentity 身份证

ClaimsPrincipal 身份持有人

## 杨中科

用EFcore进行操作.

`Microsoft.AspNetCore.Identity.EntityFrameworkCore`

一个人(ClaimsPrincipal)有很多身份(ClaimsIdentity),一个身份有很多属性(Claim)

在web中, HttpContext.SignInAsync(\"MyCookieAuth\",ClaimsPrincipal);

必须在容器中注册 :

    //注册认证，并且使用项目中名为MyCookieAuth的Cookie,在网页中Cookie的Name也为MyCookieAuth.
    builder.Services.AddAuthentication().AddCookie("MyCookieAuth",options=>
    {
        options.Cookie.Name="MyCookieAuth"
    }
    )

TKey为主键类型

IdentityUser\<TKey\>

IdentityRole\<TKey\>

IdentityDbContext\<TUser,TRole,TKey\>

### 配置

`Services.AddDataProtection();` Web数据加密

`Services.AddIdentity();` 默认行为，有用户和角色服务

`Services.AddIdentityCore();` 只有用户服务，不需要角色管理

`Services.AddDefaultIdentity();` 有用户和角色额外再集成UI.

    //默认的密码强度非常高，建议修改。
    //返回IdentityBuidler
    services.AddIdentityCore<IdentityUser>(options=>
    {
        options.Password.RequireDigit = false;
        options.Password.RequireLowercase = false;
        options.Password.RequireUppercase = false;
        options.Password.RequiredLength = 1;
        //需要非数字字母字符
        options.Password.RequireNonAlphanumeric = false;
    });

`IdentityBuidler AddEntityFrameworkStores();`
将Identity框架与EFcore关联，使用EFcore操作Identity；

`IdentityBuidler AddUserManager(TManager);` 添加用户管理器

`IdentityBuidler AddRoleManager(TManager);` 添加角色管理器

### Manager

[userManager.CreateAsync]{#usermanager.createasync}(IdentityUser,password)

> 需要new IdentityUser()传入参数.不是单纯的传入账号和密码字符串
>
> 第二个参数直接传入string就可以，框架会自动变成passwordhash
>
> 别忘了Dbcontext.SaveChangesAsync();

</details>